{
	"header":{
    "prefix":"header",
    "body":[
      "#include<bits/stdc++.h>",
      "using namespace std;",
			"$1",
      "int main(){",
      "\t$2",
      "}"
      ]
  },
	"ac-library":{
    "prefix":"ac-library",
    "body":[
      "#include<atcoder/all>",
      "using namespace atcoder;"
    ]
  },
  "INF":{
    "prefix":"INF",
    "body":["#define INF ${1:1en}"]
  },
  "string find":{
    "prefix":"string find",
    "body":["${1:string}.find(\"${2:string}\")"]
  },
  "string exist":{
    "prefix":"string exist",
    "body":["if(${1:string}.find(\"${2:string}\")!=string::npos)"]
  },
  "string substr":{
    "prefix":"string substr",
    "body":["${1:string}.substr(${2:pos}${3:,len})"]
  },
  "string erase":{
    "prefix":"string erase",
    "body":["${1:string}.erase(${2:pos}${3:,len})"]
  },
  "string insert":{
    "prefix":"string insert",
    "body":["${1:string}.insert(${2:pos},${3:\"string\"})"]
  },
  "string replace":{
    "prefix":"string replace",
    "body":["${1:string}.replace(${2:pos},${3:len},${4:\"string\"})"]
  },
  "string reverse":{
    "prefix":"string reverse",
    "body":["reverse(${1:string}.begin(),${1:string}.end());"]
  },
  "string sort":{
    "prefix":"string sort",
    "body":["sort(${1:string}.begin(),${1:string}.end());"]
  },
  "string descending sort":{
    "prefix":"string descending sort",
    "body":["sort(${1:string}.rbegin(),${1:string}.rend());"]
  },
  "to_string":{
    "prefix":"to_string",
    "body":["to_string(${1:number})"]
  },
  "string to int":{
    "prefix":"string to int",
    "body":["stoi(${1:string})"]
  },
  "string to double":{
    "prefix":"string to double",
    "body":["stod(${1:string})"]
  },
  "string to lower":{
    "prefix":"string to lower",
    "body":["transform(${1:string}.begin(), ${1:string}.end(), ${1:string}.begin(),tolower);"]
  },
  "string to upper":{
    "prefix":"string to upper",
    "body":["transform(${1:string}.begin(), ${1:string}.end(), ${1:string}.begin(),toupper);"]
  },
  "next iterator for set/map":{
    "prefix":"next iterator for set/map",
    "body":["next(${1:set/map}.begin(),${2:n})"]
  },
  "prev iterator for set/map":{
    "prefix":"prev iterator for set/map",
    "body":["prev(${1:set/map}.end(),${2:n})"]
  },
  "mod1998244353":{
    "prefix":"mod1000000007",
    "body":["using mint=modint1000000007;"]
  },
  "mod998244353":{
    "prefix":"mod998244353",
    "body":["using mint=modint998244353;"]
  },
  "modint":{
    "prefix":"modint",
    "body":[
      "using mint=modint;",
      "mint::set_mod(${1:mod});"
    ]
  },
  "modint val":{
    "prefix":"modint val",
    "body":["${1:x}.val()"]
  },
  "modint pow":{
    "prefix":"modint pow",
    "body":["${1:x}.pow(${2:n})"]
  },
  "modint inv":{
    "prefix":"modint inv",
    "body":["${1:x}.inv()"]
  },
  "typedef pair":{
    "prefix":"typedef pair",
    "body":["typedef pair<${1:type},${2:type}>${3:P};"]
  },
  "tie pair":{
    "prefix":"tie pair",
    "body":["tie(${1:a},${2:b})=${3:pair}"]
  },
  "tuple get":{
    "prefix":"tuple get",
    "body":["get<${1:0}>(${2:tuple})"]
  },
  "array size":{
    "prefix":"array size",
    "body":["${1:array}.size()"]
  },
  "array count":{
    "prefix":"array count",
    "body":["count(${1:array},${1:array}+${2:N},${3:value})"]
  },
  "array find":{
    "prefix":"array find",
    "body":["auto ${1:iterator}=find(${2:array},${2:array}+${3:N},${4:value});"]
  },
  "array fill":{
    "prefix":"array fill",
    "body":["fill(${1:array},${1:array}+${2:N},${3:value});"]
  },
  "array fill 2d":{
    "prefix":"array fill 2d",
    "body":["fill(${1:array}[0],${1:array}[${2:H}],${3:value});"]
  },
  "array fill 3d":{
    "prefix":"array fill 3d",
    "body":["fill(${1:array}[0][0],${1:array}[${2:N}][0],${3:value});"]
  },
  "array sort":{
    "prefix":"array sort",
    "body":["sort(${1:array},${1:array}+${2:N});"]
  },
  "array descending sort":{
    "prefix":"array descending sort",
    "body":["sort(${1:array},${1:array}+${2:N},greater<${3:type}>());"]
  },
  "array pair second sort":{
    "prefix":"array pair second sort",
    "body":["sort(${1:array},${1:array}+${2:N},[](auto x, auto y){return x.second<y.second;});"]
  },
  "array lower_bound":{
    "prefix":"array lower_bound",
    "body":["auto ${1:iterator not less than value}=lower_bound(${2:sorted array},${2:sorted array}+${3:N},{4:value});"]
  },
  "array upper_bound":{
    "prefix":"array upper_bound",
    "body":["auto ${1:iterator greater than value}=upper_bound(${2:sorted array},${2:sorted array}+${3:N},{4:value});"]
  },
  "array max":{
    "prefix":"array max",
    "body":["*max_element(${1:array},${1:array}+${2:N})"]
  },
  "array min":{
    "prefix":"array min",
    "body":["*min_element(${1:array},${1:array}+${2:N})"]
  },
  "array accumulate":{
    "prefix":"array accumulate",
    "body":["accumulate(${1:array},${1:array}+${2:N},0)"]
  },
  "vector insert":{
    "prefix":"vector insert",
    "body":["${1:vector}.insert(${1:vector}.begin()+${2:n},${3:value});"]
  },
  "vector erase":{
    "prefix":"vector erase",
    "body":["${1:vector}.erase(${1:vector}.begin()+${2:n});"]
  },
  "vector erase value":{
    "prefix":"vector erase vpalue",
    "body":["erase(${1:vector},${2:value});"]
  },
  "vector size":{
    "prefix":"vector size",
    "body":["${1:vector}.size()"]
  },
  "vector resize":{
    "prefix":"vector resize",
    "body":["${1:vector}.resize(${2:n})"]
  },
  "vector count":{
    "prefix":"vector count",
    "body":["count(${1:vector}.begin(),${1:vector}.end(),${2:value})"]
  },
  "vector find":{
    "prefix":"vector find",
    "body":["auto ${1:iterator}=find(${2:vector}.begin(),${2:vector}.end(),${3:value});"]
  },
  "vector fill":{
    "prefix":"vector fill",
    "body":["fill(${1:vector}.begin(),${1:vector}.end(),${2:value});"]
  },
  "vector sort":{
    "prefix":"vector sort",
    "body":["sort(${1:vector}.begin(),${1:vector}.end());"]
  },
  "vector descending sort":{
    "prefix":"vector descending sort",
    "body":["sort(${1:vector}.rbegin(),${1:vector}.rend());"]
  },
  "vector lower_bound":{
    "prefix":"vector lower_bound",
    "body":["auto ${1:iterator not less than value}=lower_bound(${2:sorted vector}.begin(),${2:sorted vector}.end(),{3:value});"]
  },
  "vector upper_bound":{
    "prefix":"vector upper_bound",
    "body":["auto ${1:iterator greater than value}=upper_bound(${2:sorted vector}.begin(),${2:sorted vector}.end(),{3:value});"]
  },
  "vector max":{
    "prefix":"vector max",
    "body":["*max_element(${1:vector}.begin(),${1:vector}.end())"]
  },
  "vector min":{
    "prefix":"vector min",
    "body":["*min_element(${1:vector}.begin(),${1:vector}.end())"]
  },
  "vector accumulate":{
    "prefix":"vector accumulate",
    "body":["accumulate(${1:vector},${1:vector}+${2:N},0)"]
  },
  "set":{
    "prefix":"set",
    "body":["set<${1:type}>$2${3:'{}'}"]
  },
  "set insert":{
    "prefix":"set insert",
    "body":["${1:set}.insert(${2:value});"]
  },
  "set erase":{
    "prefix":"set erase",
    "body":["${1:set}.erase(${2:value/iterator});"]
  },
  "set find":{
    "prefix":"set find",
    "body":["auto ${1:iterator}=${2:set}.find(${3:value});"]
  },
  "set lower_bound":{
    "prefix":"set lower_bound",
    "body":["auto ${1:iterator not less than value}=${2:set}.lower_bound(${3:value});"]
  },
  "set upper_bound":{
    "prefix":"set upper_bound",
    "body":["auto ${1:iterator greater than value}=${2:set}.upper_bound(${3:value});"]
  },
  "set accumulate":{
    "prefix":"set accumulate",
    "body":["accumulate(${1:set}.begin(),${1:set}.end(),0)"]
  },
  "descending order set":{
    "prefix":"descending order set",
    "body":["set<${1:type},greater<${1:type}>>$2"]
  },
  "multiset":{
    "prefix":"multiset",
    "body":["multiset<${1:type}>$2"]
  },
  "map":{
    "prefix":"map",
    "body":["map<${1:type},${2:type}>$3"]
  },
  "map first":{
    "prefix":"map first",
    "body":["${1:map}.first"]
  },
  "map second":{
    "prefix":"map second",
    "body":["${1:imap}.second"]
  },
  "map erase":{
    "prefix":"map erase",
    "body":["${1:map}.erase(${2:key/iterator});"]
  },
  "map count":{
    "prefix":"map count",
    "body":["${1:map}.count(${2:key})"]
  },
  "map find":{
    "prefix":"map find",
    "body":["auto ${1:iterator}=${2:map}.find(${3:key});"]
  },
  "map lower_bound":{
    "prefix":"map lower_bound",
    "body":["auto ${1:iterator not less than value}=${2:map}.lower_bound(${3:value});"]
  },
  "map upper_bound":{
    "prefix":"map upper_bound",
    "body":["auto ${1:iterator greater than value}=${2:map}.upper_bound(${3:value});"]
  },
  "descending order map":{
    "prefix":"descending order map",
    "body":["map<${1:type},${2:type},greater<${1:type}>>$3"]
  },
  "multimap":{
    "prefix":"multimap",
    "body":["multimap<${1:type},${2:type}>$3"]
  },
  "multimap insert":{
    "prefix":"multimap insert",
    "body":["${1:multimap}.insert(${2:key},${3:value});"]
  },
  "multimap first":{
    "prefix":"multimap first",
    "body":["${1:multimap}.first"]
  },
  "multimap second":{
    "prefix":"multimap second",
    "body":["${1:multimap}.second"]
  },
  "queue":{
    "prefix":"queue",
    "body":["queue<${1:type}>$2"]
  },
  "priority_queue":{
    "prefix":"priority_queue",
    "body":["priority_queue<${1:type}>$2"]
  },
  "ascending order priority_queue":{
    "prefix":"ascending order priority_queue",
    "body":["priority_queue<${1:type},vector<${1:type}>,greater<${1:type}>>$2"]
  },
  "set_intersection":{
    "prefix":"set_intersection",
    "body":["set_intersection(${1:sorted STL container}.begin(),${1:sorted STL container}.end(),${2:sorted STL container}.begin(),${2:sorted STL container}.end(),back_inserter(${3:STL container}));"]
  },
  "set_union":{
    "prefix":"set_union",
    "body":["set_union(${1:sorted STL container}.begin(),${1:sorted STL container}.end(),${2:sorted STL container}.begin(),${2:sorted STL container}.end(),back_inserter(${3:STL container}));"]
  },
  "set_difference":{
    "prefix":"set_difference",
    "body":["set_difference(${1:sorted STL container}.begin(),${1:sorted STL container}.end(),${2:sorted STL container}.begin(),${2:sorted STL container}.end(),back_inserter(${3:STL container}));"]
  },
  "max":{
    "prefix":"max",
    "body":["max({$1,$2,$3})"]
  },
  "min":{
    "prefix":"min",
    "body":["min({$1,$2,$3})"]
  },
  "pow":{
    "prefix":"pow",
    "body":["pow($1,$2)"]
  },
  "round":{
    "prefix":"round",
    "body":["round($1)"]
  },
  "ceil":{
    "prefix":"ceil",
    "body":["ceil($1)"]
  },
  "round down":{
    "prefix":"round down in division",
    "body":["(${1:dividend}+${2:divisor}-1)/${2:divisor}"]
  },
  "floor":{
    "prefix":"floor",
    "body":["floor($1)"]
  },
  "Greatest Common Divisor":{
    "prefix":"Greatest Common Divisor",
    "body":["gcd($1,$2)"]
  },
  "Least Common Multiple":{
    "prefix":"Least Common Multiple",
    "body":["lcm($1,$2)"]
  },
  "for":{
    "prefix":"for",
    "body":["for(int ${1:i}=${2:0};${1:i}<$3${4:N};${1:i}++)"]
  },
  "for_each":{
    "prefix":"for_each",
    "body":["for_each(${1:STL container}.begin(),${1:STL container}.end(),[](${2:type} x){cout<<x<<' ';}); cout<<endl;"]
  },
  "all_of":{
    "prefix":"all_of",
    "body":["all_of(${1:STL container}.begin(),${1:STL container}.end(),[](${2:type} x){return ${3:f(x)};})"]
  },
  "any_of":{
    "prefix":"any_of",
    "body":["any_of(${1:STL container}.begin(),${1:STL container}.end(),[](${2:type} x){return ${3:f(x)};})"]
  },
  "none_of":{
    "prefix":"none_of",
    "body":["none_of(${1:STL container}.begin(),${1:STL container}.end(),[](${2:type} x){return ${3:f(x)};})"]
  },
  "cin":{
    "prefix":"cin",
    "body":["cin>>$1;"]
  },
  "cout":{
    "prefix":"cout",
    "body":["cout<<$1<<endl;"]
  },
  "Yes or No":{
    "prefix":"yes or no",
    "body":["cout<<(${1:bool}?\"Yes\":\"No\")<<endl;"]
  },
  "enumeration":{
    "prefix":"enumeration",
    "body":["for(int i=0;i<N;i++)cout<<${1:answer}[i]<<\" \\n\"[i==N-1];"]
  },
  "setprecision":{
    "prefix":"fixed_setprecision",
    "body":["fixed<<setprecision($1)<<"]
  },
  "recursion":{
    "prefix":"recursion",
    "body":[
      "${1:type} f(${2:type} i){",
      "\tif(i==0)return value;",
      "\telse return function(f(i-1));",
      "}"
    ]
  },
  "exit":{
    "prefix":"exit",
    "body":["exit(0);"]
  },
  "Knapsack DP":{
    "prefix":"Knapsack DP",
    "body":[
      "for(int i=0;i<N;i++)for(int j=W;j>=w[i];j--)",
      "\tdp[j]=max(dp[j],dp[j-w[i]]+v[i]",
      "}",
      "cout<<dp[W]<<endl;"
    ]
  },  
  "Unbounded Knapsack DP":{
    "prefix":"Unbounded Knapsack DP",
    "body":[
      "for(int i=0;i<N;i++)for(int j=w[i];j<=W;j++)",
      "\tdp[j]=max(dp[j],dp[j-w[i]]+v[i]",
      "}",
      "cout<<dp[W]<<endl;"
    ]
  },  
  "undirected graph":{
    "prefix":"undirected graph",
    "body":[
      "int u,v; for(int i=0;i<M;i++){cin>>u>>v;",
      "\tG[u].push_back(v),G[v].push_back(u);",
      "}"
    ]
  },
  "Depth-First Serch":{
    "prefix":"Depth-First Serch",
    "body":[
      "void dfs(int i){",
      "\td[i]=1;",
      "\tfor(int j:G[i])if(!d[j]){",
      "\t\tv[j]=v[i]+1; dfs(j);",
      "\t}",
      "}"
    ]
  },
  "Breadth-First Serch":{
    "prefix":"Breadth-First Serch",
    "body":[
      "queue<int>q; q.push(1); while(q.size()){",
      "\tint i=q.front(); q.pop();",
      "\tfor(int j:G[i])if(!d[j]){",
      "\t\tv[j]=v[i]+1; q.push(j);",
      "\t}",
      "}"
    ]
  },
  "Floyd-Warshall":{
    "prefix":"Floyd-Warshall",
    "body":[
      "fill(${1:d}[0],${1:d}[${2:N}],INF);",
      "int u,v,di; for(int i=0;i<${3:M};i++)cin>>u>>v>>di,${1:d}d[u][v]=di;",
      "for(int k=1;k<=${2:N};k++)",
      "\tfor(int i=1;i<=${2:N};i++)",
      "\t\tfor(int j=1;j<=${2:N};j++)",
      "\t\t\t${1:d}[i][j]=min(${1:d}[i][j],${1:d}[i][k]+${1:d}[k][j]);"
    ]
  },
  "Topological Sort":{
    "prefix":"Topological Sort",
    "body":[
      "int u,v; for(int i=0;i<M;i++){cin>>u>>v;",
      "\tG[u].push_back(v); ind[v]++;",
      "}",
      "for(int i=1;i<=N;i++)if(!ind[i])q.push(i);",
      "while(q.size()){",
      "\tint j=q.front(); q.pop(); a.push_back(j);",
      "\tfor(int k:G[j])if(!--ind[k])q.push(k);",
      "}"
    ]
  },
  "Union-Find constructor":{
    "prefix":"Union-Find constructor",
    "body":["dsu ${1:d}(${2:N});"]
  },
  "Union-Find marge":{
    "prefix":"Union-Find marge",
    "body":["${1:d}.merge(${2:u},${3:v});"]
  },
  "Union-Find same":{
    "prefix":"Union-Find same",
    "body":["${1:d}.same(${2:u},${3:v})"]
  },
  "Union-Find leader":{
    "prefix":"Union-Find leader",
    "body":["${1:d}.leader(${2:i})"]
  },
  "Union-Find size":{
    "prefix":"Union-Find size",
    "body":["${1:d}.size(${2:i})"]
  },
  "grid move":{
    "prefix":"grid move",
    "body":[
      "int di[]={-1,0,1,0},dj[]={0,1,0,-1};",
      "for(int k=0;k<4;k++){",
      "\tint ni=i+di[k],nj=j+dj[k];",
      "\tif(!f[ni][nj])f[ni][nj]=f[i][j]+1;",
      "}"
    ]
  },
  "Eratosthenes prime":{
    "prefix":"Eratosthenes prime",
    "body":[
      "vector<int64_t>e; vector<bool>p(${1:N}+1);",
      "for(int i=2;i<=${1:N};i++){if(p[i])continue;",
      "\te.push_back(i); for(int j=i;j<=${1:N};j+=i)p[j]=1;",
      "}"
    ]
  },
  "integer factorization":{
    "prefix":"integer factorization",
    "body":[
      "map<int,int>f;",
      "for(int64_t i=2;i*i<=n;i++)if(n%i==0)",
      "\twhile(d%i==0)f[i]++,n/=i;",
      "if(n>1)f[n]++;"
    ]
  },
  "binary string to int":{
    "prefix":"binary string to int",
    "body":[
      "int64_t a=0;b=1; for(int i=s.size()-1;i>=0;i--){",
      "\tif(s[i]==\"1\")a+=b; a*=2;",
      "}"
    ]
  },
  "next_permutation":{
    "prefix":"next_permutation",
    "body":[
      "do{$1",
      "}while(next_permutation(${2:sorted vector}.begin(),${2:sorted vector}.end()));"
    ]
  },
}